? config.h
? stamp-h1
? libtelnet/foo
? telnet/ggg
? telnet/hhh
Index: README
===================================================================
RCS file: /cvsroot/inetutils/inetutils/README,v
retrieving revision 1.10
diff -u -p -r1.10 README
--- README	25 Dec 2001 18:47:44 -0000	1.10
+++ README	25 Nov 2002 17:54:43 -0000
@@ -47,6 +47,12 @@ not want to install these files.
 install setuid root to work correctly they use priviledge ports
 for communication. 
 
+3) If both Kerberos 5 (MIT and Heimdal) and Shishi is specified,
+   the applications that have been ported to use Shishi will use Shishi
+   only, and the applications that have not been ported to use Shishi
+   will use MIT or Heimdal Kerberos.  If you want MIT or Heimdal instead
+   of Shishi, don't specify --with-shishi.
+
 Some known deficiencies:
  o Many programs do not support long options, such as --version or --help.
  o The authentication and encryption options have not been tested.
Index: configure.ac
===================================================================
RCS file: /cvsroot/inetutils/inetutils/configure.ac,v
retrieving revision 1.14
diff -u -p -r1.14 configure.ac
--- configure.ac	15 Nov 2002 14:07:34 -0000	1.14
+++ configure.ac	25 Nov 2002 17:54:43 -0000
@@ -63,6 +63,8 @@ AC_ARG_WITH(krb4, [  --with-krb4[[=PATH]
 AC_ARG_WITH(krb5, [  --with-krb5[[=PATH]]      Compile with Kerberos V],
             [KERBEROS_VERSION=5
              KERBEROS_DIR=$withval])
+AC_ARG_WITH(shishi, AC_HELP_STRING([--with-shishi],
+                                   [Compile with Shishi (Kerberos 5)]))
 AC_ARG_WITH(wrap, [  --with-wrap    add tcp wrapper support])
 AC_ARG_WITH(pam,  [  --with-pam    add support for PAM])
 
@@ -245,6 +247,7 @@ if test "$enable_encryption" = yes -o "$
   AH_TEMPLATE(DES_ENCRYPTION, [FIXME])
   AH_TEMPLATE(KERBEROS_V, [Define to one if you have Kerberos V])
   AH_TEMPLATE(KRB5, [Define to one if you have Kerberos V])
+  AH_TEMPLATE(SHISHI, [Define to 1 if you have Shishi])
   
   if test "$KERBEROS_VERSION" = 4; then
     AC_CHECK_LIB(krb, krb_mk_req,
@@ -279,6 +282,14 @@ if test "$enable_encryption" = yes -o "$
       esac
     fi
   fi
+
+  if test "$with_shishi" = "yes"; then
+    PKG_CHECK_MODULES(SHISHI, shishi >= 0.0.0)
+    LIBAUTH="$LIBAUTH $SHISHI_LIBS"
+    INCAUTH="$INCAUTH $SHISHI_CFLAGS"
+    AC_DEFINE(SHISHI)
+  fi
+
 fi
 AC_SUBST(LIBAUTH)
 AC_SUBST(INCAUTH)
Index: libtelnet/Makefile.am
===================================================================
RCS file: /cvsroot/inetutils/inetutils/libtelnet/Makefile.am,v
retrieving revision 1.5
diff -u -p -r1.5 Makefile.am
--- libtelnet/Makefile.am	8 Apr 2002 14:02:39 -0000	1.5
+++ libtelnet/Makefile.am	25 Nov 2002 17:54:44 -0000
@@ -4,6 +4,6 @@ INCLUDES = -I$(top_builddir)/include @IN
 
 noinst_LIBRARIES = libtelnet.a
 
-libtelnet_a_SOURCES = auth.c enc_des.c encrypt.c forward.c genget.c getent.c kerberos.c kerberos5.c misc.c read_passwd.c
+libtelnet_a_SOURCES = auth.c enc_des.c encrypt.c forward.c genget.c getent.c kerberos.c kerberos5.c shishi.c misc.c read_passwd.c
 
 noinst_HEADERS = auth-proto.h auth.h enc-proto.h encrypt.h key-proto.h misc-proto.h misc.h
Index: libtelnet/auth-proto.h
===================================================================
RCS file: /cvsroot/inetutils/inetutils/libtelnet/auth-proto.h,v
retrieving revision 1.2
diff -u -p -r1.2 auth-proto.h
--- libtelnet/auth-proto.h	6 Jul 2000 04:21:08 -0000	1.2
+++ libtelnet/auth-proto.h	25 Nov 2002 17:54:44 -0000
@@ -89,4 +89,13 @@ void kerberos5_reply P((Authenticator *,
 int kerberos5_status P((Authenticator *, char *, int));
 void kerberos5_printsub P((unsigned char *, int, unsigned char *, int));
 #endif
+
+#ifdef	SHISHI
+int krb5shishi_init P((Authenticator *, int));
+int krb5shishi_send P((Authenticator *));
+void krb5shishi_is P((Authenticator *, unsigned char *, int));
+void krb5shishi_reply P((Authenticator *, unsigned char *, int));
+int krb5shishi_status P((Authenticator *, char *, int));
+void krb5shishi_printsub P((unsigned char *, int, unsigned char *, int));
+#endif
 #endif
Index: libtelnet/auth.c
===================================================================
RCS file: /cvsroot/inetutils/inetutils/libtelnet/auth.c,v
retrieving revision 1.5
diff -u -p -r1.5 auth.c
--- libtelnet/auth.c	6 Jul 2000 04:21:08 -0000	1.5
+++ libtelnet/auth.c	25 Nov 2002 17:54:44 -0000
@@ -126,6 +126,22 @@ Authenticator authenticators[] = {
 				spx_status,
 				spx_printsub },
 #endif
+#ifdef	SHISHI
+	{ AUTHTYPE_KERBEROS_V5, AUTH_WHO_CLIENT|AUTH_HOW_MUTUAL,
+				krb5shishi_init,
+				krb5shishi_send,
+				krb5shishi_is,
+				krb5shishi_reply,
+				krb5shishi_status,
+				krb5shishi_printsub },
+	{ AUTHTYPE_KERBEROS_V5, AUTH_WHO_CLIENT|AUTH_HOW_ONE_WAY,
+				krb5shishi_init,
+				krb5shishi_send,
+				krb5shishi_is,
+				krb5shishi_reply,
+				krb5shishi_status,
+				krb5shishi_printsub },
+#endif
 #ifdef	KRB5
 # ifdef	ENCRYPTION
 	{ AUTHTYPE_KERBEROS_V5, AUTH_WHO_CLIENT|AUTH_HOW_MUTUAL,
@@ -217,9 +233,18 @@ auth_init(name, server)
 		if (!ap->init || (*ap->init)(ap, server)) {
 			i_support |= typemask(ap->type);
 			if (auth_debug_mode)
-				printf(">>>%s: I support auth type %d %d\r\n",
+				printf(">>>%s: I support auth type %s (%d) %s (%d)\r\n",
 					Name,
-					ap->type, ap->way);
+				       AUTHTYPE_NAME_OK(ap->type) ?
+				       AUTHTYPE_NAME(ap->type) : 
+				       "unknown",
+				       ap->type,
+				       ap->way & 
+				       AUTH_HOW_MASK & 
+				       AUTH_HOW_MUTUAL ? 
+				       "MUTUAL" : 
+				       "ONEWAY",
+				       ap->way);
 		}
 		else if (auth_debug_mode)
 			printf(">>>%s: Init failed: auth type %d %d\r\n",
@@ -429,16 +454,34 @@ auth_send(data, cnt)
 	}
 	while ((auth_send_cnt -= 2) >= 0) {
 		if (auth_debug_mode)
-			printf(">>>%s: He supports %d\r\n",
-				Name, *auth_send_data);
+			printf(">>>%s: He supports %s (%d) %s (%d)\r\n",
+			       Name,  AUTHTYPE_NAME_OK(auth_send_data[0]) ?
+			       AUTHTYPE_NAME(auth_send_data[0]) : 
+			       "unknown",
+			       auth_send_data[0],
+			       auth_send_data[1] & 
+			       AUTH_HOW_MASK & 
+			       AUTH_HOW_MUTUAL ? 
+			       "MUTUAL" : 
+			       "ONEWAY",
+			       auth_send_data[1]);
 		if ((i_support & ~i_wont_support) & typemask(*auth_send_data)) {
 			ap = findauthenticator(auth_send_data[0],
 					       auth_send_data[1]);
 			if (ap && ap->send) {
 				if (auth_debug_mode)
-					printf(">>>%s: Trying %d %d\r\n",
-						Name, auth_send_data[0],
-							auth_send_data[1]);
+					printf(">>>%s: Trying %s (%d) %s (%d)\r\n",
+					       Name, 
+					       AUTHTYPE_NAME_OK(auth_send_data[0]) ?
+					       AUTHTYPE_NAME(auth_send_data[0]) : 
+					       "unknown",
+					       auth_send_data[0],
+					       auth_send_data[1] & 
+					       AUTH_HOW_MASK & 
+					       AUTH_HOW_MUTUAL ? 
+					       "MUTUAL" : 
+					       "ONEWAY",
+					       auth_send_data[1]);
 				if ((*ap->send)(ap)) {
 					/*
 					 * Okay, we found one we like
@@ -446,8 +489,12 @@ auth_send(data, cnt)
 					 * we can go home now.
 					 */
 					if (auth_debug_mode)
-						printf(">>>%s: Using type %d\r\n",
-							Name, *auth_send_data);
+						printf(">>>%s: Using type %s (%d)\r\n",
+							Name, 
+						       AUTHTYPE_NAME_OK(*auth_send_data) ?
+						       AUTHTYPE_NAME(*auth_send_data) : 
+						       "unknown",
+						       *auth_send_data);
 					auth_send_data += 2;
 					return;
 				}
Index: libtelnet/kerberos5.c
===================================================================
RCS file: /cvsroot/inetutils/inetutils/libtelnet/kerberos5.c,v
retrieving revision 1.7
diff -u -p -r1.7 kerberos5.c
--- libtelnet/kerberos5.c	13 Sep 2002 10:46:49 -0000	1.7
+++ libtelnet/kerberos5.c	25 Nov 2002 17:54:44 -0000
@@ -45,6 +45,10 @@
 # define KRB5_ENV_CCNAME "KRB5CCNAME"
 #endif
 
+#ifdef  ENCRYPTION
+#include "encrypt.h"
+#endif
+
 #ifdef  FORWARD
 /* FIXME: This is set directly from telnet/main.c */
 int forward_flags = 0;  
@@ -361,9 +365,12 @@ kerberos5_reply (Authenticator *ap, unsi
 	    }
 	  telnet_encrypt_key (&skey);
 	}
-      
+
       if (cnt)
-	printf ("[ Kerberos V5 accepts you as ``%.*s'' ]\r\n", cnt, data);
+	printf ("[ Kerberos V5 accepts you as ``%.*s''%s ]\r\n", cnt, data,
+		mutual_complete ?
+		" (server authenticated)" : 
+		" (server NOT authenticated)");
       else
 	printf ("[ Kerberos V5 accepts you ]\r\n");
       auth_finished(ap, AUTH_USER);
@@ -391,7 +398,7 @@ kerberos5_reply (Authenticator *ap, unsi
 	      auth_send_retry ();
 	      break;
 	    }
-	  
+
 	  krb5_free_ap_rep_enc_part (telnet_context, reply);
 	  telnet_encrypt_key (&skey);
 	  mutual_complete = 1;
Index: libtelnet/shishi.c
===================================================================
RCS file: libtelnet/shishi.c
diff -N libtelnet/shishi.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ libtelnet/shishi.c	25 Nov 2002 17:54:44 -0000
@@ -0,0 +1,706 @@
+/* Copyright (C) 2002 Simon Josefsson
+
+   This file is not part of GNU Inetutils, but the same permissions apply.
+
+   GNU Inetutils is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   GNU Inetutils is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GNU Inetutils; see the file COPYING.  If not, write to
+   the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA. */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#ifdef SHISHI
+#include <stdlib.h>
+#include <stdio.h>
+#include <arpa/telnet.h>
+#include <shishi.h>
+#include <krb5.h>
+#include <assert.h>
+
+#include <com_err.h>
+#include <netdb.h>
+#include <ctype.h>
+#include <syslog.h>
+#ifdef  HAVE_STRING_H
+# include <string.h>
+#else
+# include <strings.h>
+#endif
+
+#include "auth.h"
+#include "misc.h"
+
+#ifndef KRB5_ENV_CCNAME
+# define KRB5_ENV_CCNAME "KRB5CCNAME"
+#endif
+
+#ifdef  ENCRYPTION
+#include "encrypt.h"
+#endif
+
+static unsigned char str_data[2048] = { IAC, SB, TELOPT_AUTHENTICATION, 0,
+					AUTHTYPE_KERBEROS_V5, };
+
+#define KRB_AUTH             0       /* Authentication data follows */
+#define KRB_REJECT           1       /* Rejected (reason might follow) */
+#define KRB_ACCEPT           2       /* Accepted */
+#define KRB_RESPONSE         3       /* Response for mutual auth. */
+
+krb5_auth_context auth_context = 0;
+krb5_context telnet_context = 0;
+Shishi *shishi_handle = 0;
+Shishi_ap *auth_handle;
+
+static  krb5_data auth; /* session key for telnet */
+static  krb5_ticket *ticket = NULL; /* telnet matches the AP_REQ and
+				       AP_REP with this */
+
+krb5_keyblock   *session_key = 0;
+char *telnet_srvtab = NULL;
+char *telnet_krb5_realm = NULL;
+
+#define DEBUG(c) if (auth_debug_mode) printf c
+
+static int
+Data (Authenticator *ap, int type, unsigned char *d, int c)
+{
+  unsigned char *p = str_data + 4;
+  unsigned char *cd = (unsigned char *) d;
+
+  if (c == -1)
+    c = strlen (cd);
+
+  if (auth_debug_mode)
+    {
+      printf ("%s:%d: [%d] (%d)",
+	      str_data[3] == TELQUAL_IS ? ">>>IS" : ">>>REPLY",
+	      str_data[3],
+	      type, c);
+      printd (d, c);
+      printf ("\r\n");
+    }
+
+  *p++ = ap->type;
+  *p++ = ap->way;
+  *p++ = type;
+
+  while (c-- > 0) {
+    if ((*p++ = *cd++) == IAC)
+      *p++ = IAC;
+  }
+  *p++ = IAC;
+  *p++ = SE;
+  if (str_data[3] == TELQUAL_IS)
+    printsub ('>', &str_data[2], p - &str_data[2]);
+  return (net_write (str_data, p - str_data));
+}
+
+/* FIXME: Reverse return code! */
+int
+krb5shishi_init (Authenticator *ap, int server)
+{
+  str_data[3] = server ? TELQUAL_REPLY : TELQUAL_IS;
+  if (shishi_handle == 0 && shishi_init(&shishi_handle))
+    return 0;
+  if (telnet_context == 0 && krb5_init_context(&telnet_context))
+    return 0;
+  return 1;
+}
+
+void
+krb5shishi_cleanup ()
+{
+  krb5_ccache ccache;
+  char *ccname;
+
+  if (telnet_context == 0)
+    return;
+
+  if (shishi_handle == 0)
+    return;
+
+  ccname = getenv (KRB5_ENV_CCNAME);
+  if (ccname)
+    {
+      if (!krb5_cc_resolve (telnet_context, ccname, &ccache))
+	krb5_cc_destroy (telnet_context, ccache);
+  }
+
+  krb5_free_context (telnet_context);
+  telnet_context = 0;
+
+  shishi_done(shishi_handle);
+  shishi_handle = 0;
+}
+
+#ifdef  ENCRYPTION
+
+void
+encryption_init (krb5_creds *creds)
+{
+  krb5_keyblock *newkey = 0;
+  
+  krb5_auth_con_getlocalsubkey (telnet_context, auth_context, &newkey);
+  if (session_key)
+    {
+      krb5_free_keyblock (telnet_context, session_key);
+      session_key = 0;
+    }
+
+  if (newkey)
+    {
+      switch (newkey->enctype)
+	{
+	case ENCTYPE_DES_CBC_CRC:
+	case ENCTYPE_DES_CBC_MD5:
+	  krb5_copy_keyblock (telnet_context, newkey, &session_key);
+	  break;
+
+	default:
+	  switch (creds->keyblock.enctype)
+	    {
+	    case ENCTYPE_DES_CBC_CRC:
+	    case ENCTYPE_DES_CBC_MD5:
+	      krb5_copy_keyblock (telnet_context, &creds->keyblock,
+				  &session_key);
+	      break;
+
+	    default:
+	      DEBUG(("can't determine which keyblock to use"));
+	      /*FIXME: abort?*/
+	    }
+	}
+
+      krb5_free_keyblock(telnet_context, newkey);
+    }
+}
+
+#else
+# define encryption_init(c)
+#endif
+
+int
+krb5shishi_send (Authenticator *ap)
+{
+  int ap_opts;
+  char type_check[2];
+  Shishi_ticket *tkt;
+  int rc;
+  char *tmp;
+  char apreq[4096];
+  int apreq_len;
+
+  tmp = malloc(strlen("host/") + strlen(RemoteHostName) + 1);
+  sprintf(tmp, "host/%s", RemoteHostName);
+  tkt = shishi_ticketset_find_ticket_for_server
+    (shishi_handle, NULL, tmp);
+  free(tmp);
+  if (!tkt)
+    {
+      DEBUG(("telnet: Kerberos V5: no shishi ticket for server\r\n"));
+      return 0;
+    }
+
+  if (!UserNameRequested)
+    {
+      DEBUG(("telnet: Kerberos V5: no user name supplied\r\n"));
+      return 0;
+    }
+
+  // creds.keyblock.enctype = ENCTYPE_DES_CBC_CRC;
+
+  if ((ap->way & AUTH_HOW_MASK) == AUTH_HOW_MUTUAL)
+    ap_opts = SHISHI_APOPTIONS_MUTUAL_REQUIRED;
+  else
+    ap_opts = 0;
+
+#if 0
+  // ENCRYPTION
+  ap_opts |= SHISHI_APOPTIONS_USE_SESSION_KEY;
+#endif 
+
+  //krb5_auth_con_setflags (telnet_context, auth_context,
+  // KRB5_AUTH_CONTEXT_RET_TIME);
+
+  type_check[0] = ap->type;
+  type_check[1] = ap->way;
+
+  if (tkt)
+    {
+      rc = shishi_ap_data (shishi_handle, tkt, (char *) &type_check, 2, 
+			   &auth_handle);
+      if (rc != SHISHI_OK)
+	{
+	  DEBUG(("telnet: Kerberos V5: Could not make AP-REQ (%s)\r\n",
+		 shishi_strerror (rc)));
+	  return 0;
+	}
+
+      rc = shishi_apreq_options_add (shishi_handle, 
+				     shishi_ap_get_apreq (auth_handle), 
+				     ap_opts);
+      if (rc != SHISHI_OK)
+	{
+	  DEBUG(("telnet: Kerberos V5: could not set AP-Options (%s)\r\n",
+		 shishi_strerror (rc)));
+	  return 0;
+	}
+
+      if (auth_debug_mode)
+	{
+	  shishi_authenticator_print
+	    (shishi_handle, stdout, shishi_ap_get_authenticator (auth_handle));
+	  shishi_apreq_print (shishi_handle, stdout, 
+			      shishi_ap_get_apreq (auth_handle));
+	}
+
+      apreq_len = sizeof(apreq);
+      rc = shishi_ap_request_get_der (shishi_handle, auth_handle, 
+				      apreq, &apreq_len);
+      if (rc != ASN1_SUCCESS)
+	{
+	  DEBUG(("telnet: Kerberos V5: could not DER encode (%s)\r\n",
+		 shishi_strerror (rc)));
+	  return 0;
+	}
+     }
+
+  //encryption_init (new_creds);
+
+  if (!auth_sendname (UserNameRequested, strlen (UserNameRequested)))
+    {
+      DEBUG(("telnet: Not enough room for user name\r\n"));
+      return 0;
+    }
+
+  if (!Data (ap, KRB_AUTH, apreq, apreq_len))
+    {
+      DEBUG(("telnet: Not enough room for authentication data\r\n"));
+      return 0;
+    }
+
+  DEBUG(("telnet: Sent Kerberos V5 credentials to server\r\n"));
+
+  return 1;
+}
+
+#ifdef ENCRYPTION
+void
+telnet_encrypt_key (Session_Key *skey)
+{
+  if (session_key)
+    {
+      skey->type = SK_DES;
+      skey->length = 8;
+      skey->data = session_key->contents;
+      encrypt_session_key (skey, 0);
+    }
+}
+#else
+# define telnet_encrypt_key(s)
+#endif
+
+void
+krb5shishi_reply (Authenticator *ap, unsigned char *data, int cnt)
+{
+#ifdef ENCRYPTION
+  Session_Key skey;
+#endif
+  static int mutual_complete = 0;
+
+  if (cnt-- < 1)
+    return;
+  
+  switch (*data++)
+    {
+    case KRB_REJECT:
+      if (cnt > 0) 
+	printf ("[ Kerberos V5 refuses authentication because %.*s ]\r\n",
+	       cnt, data);
+      else
+	printf ("[ Kerberos V5 refuses authentication ]\r\n");
+      auth_send_retry();
+      return;
+
+    case KRB_ACCEPT:
+      if (!mutual_complete)
+	{
+	  if ((ap->way & AUTH_HOW_MASK) == AUTH_HOW_MUTUAL)
+	    {
+	      printf ("[ Kerberos V5 accepted you, but didn't provide mutual authentication! ]\r\n");
+	      auth_send_retry ();
+	      break;
+	    }
+	}
+
+      if (cnt)
+	printf ("[ Kerberos V5 accepts you as ``%.*s''%s ]\r\n", cnt, data,
+		mutual_complete ?
+		" (server authenticated)" : 
+		" (server NOT authenticated)");
+      else
+	printf ("[ Kerberos V5 accepts you ]\r\n");
+      auth_finished(ap, AUTH_USER);
+      break;
+
+    case KRB_RESPONSE:
+      if ((ap->way & AUTH_HOW_MASK) == AUTH_HOW_MUTUAL)
+	{
+	  if (shishi_ap_reply_verify_der (shishi_handle, auth_handle, 
+					  data, cnt) != SHISHI_OK)
+	    {
+	      printf ("[ Mutual authentication failed ]\r\n");
+	      auth_send_retry ();
+	      break;
+	    }
+
+	  if (auth_debug_mode)
+	    {
+	      shishi_aprep_print (shishi_handle, stdout, 
+				  shishi_ap_get_aprep (auth_handle));
+	      shishi_encapreppart_print (shishi_handle, stdout, 
+					 shishi_ap_get_encapreppart
+					 (auth_handle));
+	    }
+
+#ifdef ENCRYPTION
+	  //telnet_encrypt_key (&skey);
+#endif
+	  mutual_complete = 1;
+	}
+      break;
+
+    default:
+      DEBUG(("Unknown Kerberos option %d\r\n", data[-1]));
+    }
+}
+
+int
+krb5shishi_status (Authenticator *ap, char *name, int level)
+{
+  puts("krb5shishi_status");
+
+  if (level < AUTH_USER)
+    return level;
+
+  if (UserNameRequested
+      && krb5_kuserok (telnet_context, ticket->enc_part2->client,
+		       UserNameRequested))
+    {
+      /* FIXME: Check buffer length */
+      strcpy (name, UserNameRequested);
+      return AUTH_VALID;
+    } 
+  return AUTH_USER;
+}
+
+int
+krb5shishi_is_auth (Authenticator *ap, unsigned char *data, int cnt,
+		    char *errbuf, int errbuflen)
+{
+  int r = 0;
+  krb5_keytab keytabid = 0;
+  krb5_authenticator *authenticator;
+  char *name;
+  krb5_data outbuf;
+  krb5_keyblock *newkey = NULL;
+  krb5_principal server;
+  
+#ifdef ENCRYPTION
+  Session_Key skey;
+#endif
+  
+  puts("krb5shishi_is_auth");
+
+  auth.data = (char *)data;
+  auth.length = cnt;
+
+  if (!r && !auth_context)
+    r = krb5_auth_con_init (telnet_context, &auth_context);
+  if (!r)
+    {
+      krb5_rcache rcache;
+    
+      r = krb5_auth_con_getrcache (telnet_context, auth_context,
+				   &rcache);
+      if (!r && !rcache)
+	{
+	  r = krb5_sname_to_principal(telnet_context, 0, 0,
+				      KRB5_NT_SRV_HST, &server);
+	  if (!r)
+	    {
+	      r = krb5_get_server_rcache(telnet_context,
+					 krb5_princ_component (telnet_context,
+							       server, 0),
+					 &rcache);
+	      krb5_free_principal (telnet_context, server);
+	    }
+	}
+      if (!r)
+	r = krb5_auth_con_setrcache (telnet_context,
+				     auth_context, rcache);
+    }
+  
+  if (!r && telnet_srvtab)
+    r = krb5_kt_resolve (telnet_context, telnet_srvtab, &keytabid);
+  if (!r)
+    r = krb5_rd_req (telnet_context, &auth_context, &auth,
+		     NULL, keytabid, NULL, &ticket);
+  if (r)
+    {
+      snprintf (errbuf, errbuflen, "krb5_rd_req failed: %s",
+		error_message (r));
+      return r;
+    }
+
+  /* 256 bytes should be much larger than any reasonable
+     first component of a service name especially since
+     the default is of length 4. */
+  if (krb5_princ_component (telnet_context,ticket->server,0)->length < 256)
+    {
+      char princ[256];
+      strncpy (princ,
+	       krb5_princ_component (telnet_context, ticket->server,0)->data,
+	       krb5_princ_component (telnet_context, ticket->server,0)->length);
+      princ[krb5_princ_component (telnet_context,
+				  ticket->server,0)->length] = '\0';
+      if (strcmp ("host", princ))
+	{
+	  snprintf(errbuf, errbuflen,
+		   "incorrect service name: \"%s\" != \"host\"",
+		   princ);
+	  return 1;
+	}
+    }
+  else
+    {
+      strncpy (errbuf, "service name too long", errbuflen);
+      return 1;
+    }
+
+  r = krb5_auth_con_getauthenticator (telnet_context,
+				      auth_context,
+				      &authenticator);
+  if (r)
+    {
+      snprintf (errbuf, errbuflen,
+		"krb5_auth_con_getauthenticator failed: %s",
+		error_message (r));
+      return 1;
+    }
+
+#ifdef AUTH_ENCRYPT_MASK
+  if ((ap->way & AUTH_ENCRYPT_MASK) == AUTH_ENCRYPT_ON
+      &&  !authenticator->checksum)
+    {
+      snprintf (errbuf, errbuflen,
+		"authenticator is missing required checksum");
+      return 1;
+    }
+#endif
+  
+  if (authenticator->checksum)
+    {
+      char type_check[2];
+      krb5_checksum *cksum = authenticator->checksum;
+      krb5_keyblock *key;
+
+      type_check[0] = ap->type;
+      type_check[1] = ap->way;
+
+      r = krb5_auth_con_getkey (telnet_context, auth_context,
+				&key);
+      if (r)
+	{
+	  snprintf (errbuf, errbuflen,
+		    "krb5_auth_con_getkey failed: %s",
+		    error_message (r));
+	  return 1;
+	}
+      
+      r = krb5_verify_checksum (telnet_context,
+				cksum->checksum_type, cksum,
+				&type_check, 2, key->contents,
+				key->length);
+      
+      if (r)
+	{
+	  snprintf (errbuf, errbuflen, 
+		    "checksum verification failed: %s",
+		    error_message (r));
+	  return 1;
+	}
+      krb5_free_keyblock (telnet_context, key);
+    }
+  
+  krb5_free_authenticator (telnet_context, authenticator);
+  if ((ap->way & AUTH_HOW_MASK) == AUTH_HOW_MUTUAL)
+    {
+      if ((r = krb5_mk_rep (telnet_context, auth_context,
+			    &outbuf)))
+	{
+	  snprintf (errbuf, errbuflen, "Make reply failed: %s",
+		    error_message(r));
+	  return 1;
+	}
+
+      Data (ap, KRB_RESPONSE, outbuf.data, outbuf.length);
+    }
+  
+  if (krb5_unparse_name (telnet_context, ticket->enc_part2 ->client, &name))
+    name = 0;
+  
+  Data (ap, KRB_ACCEPT, name, name ? -1 : 0);
+  DEBUG(("telnetd: Kerberos5 identifies him as ``%s''\r\n",
+	 name ? name : ""));
+  auth_finished (ap, AUTH_USER);
+
+  if (name)
+    free (name);
+  krb5_auth_con_getremotesubkey (telnet_context, auth_context, &newkey);
+  
+  if (session_key)
+    {
+      krb5_free_keyblock (telnet_context, session_key);
+      session_key = 0;
+    }
+  
+  if (newkey)
+    {
+      krb5_copy_keyblock (telnet_context, newkey, &session_key);
+      krb5_free_keyblock (telnet_context, newkey);
+    }
+  else
+    {
+      krb5_copy_keyblock (telnet_context, ticket->enc_part2->session,
+			  &session_key);
+    }
+  telnet_encrypt_key (&skey);
+  return 0;
+}
+    
+void
+krb5shishi_is (Authenticator *ap, unsigned char *data, int cnt)
+{
+  int r = 0;
+  char errbuf[512];
+    
+  puts("krb5shishi_is");
+
+  if (cnt-- < 1)
+    return;
+  errbuf[0] = 0;
+  switch (*data++)
+    {
+    case KRB_AUTH:
+      r = krb5shishi_is_auth (ap, data, cnt, errbuf, sizeof errbuf);
+      break;
+
+    default:
+      DEBUG(("Unknown Kerberos option %d\r\n",
+	     data[-1]));
+      Data(ap, KRB_REJECT, 0, 0);
+      break;
+    }
+
+  if (r)
+    {
+      if (!errbuf[0])
+	snprintf (errbuf, sizeof errbuf,
+		  "kerberos_is: %s", error_message(r));
+      Data (ap, KRB_REJECT, errbuf, -1);
+      DEBUG(("%s\r\n", errbuf));
+      syslog (LOG_ERR, "%s", errbuf);
+      if (auth_context)
+	{
+	  krb5_auth_con_free (telnet_context, auth_context);
+	  auth_context = 0;
+	}
+    }
+}
+    
+static char *
+req_type_str (int type)
+{
+  switch (type)
+    {
+    case KRB_REJECT:
+      return "REJECT";
+      
+    case KRB_ACCEPT:
+      return "ACCEPT";
+
+    case KRB_AUTH:
+      return "AUTH";
+
+    case KRB_RESPONSE:
+      return "RESPONSE";
+
+    }
+  return NULL;
+}
+     
+#define ADDC(p,l,c) if ((l) > 0) {*(p)++ = (c); --(l);}
+
+void
+krb5shishi_printsub (unsigned char *data, int cnt,
+		     unsigned char *buf,  int buflen)
+{
+  char *p;
+  int i;
+
+  puts("krb5shishi_printsub");
+
+  buf[buflen-1] = '\0';           /* make sure its NULL terminated */
+  buflen -= 1;
+
+  p = req_type_str (data[3]);
+  if (!p)
+    {
+      int l = snprintf (buf, buflen, " %d (unknown)", data[3]);
+      buf += l;
+      buflen -= l;
+    }
+  else
+    {
+      while (buflen > 0 && (*buf++ = *p++) != 0)
+	buflen--;
+    }
+      
+  switch (data[3])
+    {
+    case KRB_REJECT:  /* Rejected (reason might follow) */
+    case KRB_ACCEPT:  /* Accepted (username might follow) */
+      if (cnt <= 4)
+	break;
+      ADDC(buf, buflen, '"');
+      for (i = 4; i < cnt; i++)
+	ADDC(buf, buflen, data[i]);
+      ADDC(buf, buflen, '"');
+      ADDC(buf, buflen, '\0');
+      break;
+
+    case KRB_AUTH:
+    case KRB_RESPONSE:
+      for (i = 4; buflen > 0 && i < cnt; i++)
+	{
+	  int l = snprintf (buf, buflen, " %d", data[i]);
+	  buf += l;
+	  buflen -= l;
+      }
+    }
+}
+     
+#endif /* SHISHI */
