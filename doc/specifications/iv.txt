To: ietf-krb-wg@anl.gov
Subject: IV problems in AES cipher
From: Simon Josefsson <jas@extundo.com>
Gcc: nnimap+yxa:INBOX.sent-mail.2003.08

The AES specification says:

   This is a summary of the parameters to be used with the simplified
   algorithm profile described in [KCRYPTO]:
...
   |  encryption/decryption functions,       AES in CBC-CTS mode with   |
   |  E and D                                zero ivec (cipher block    |
   |                                         size 16 octets)            |

It is not clear what "zero ivec" is supposed to mean, and two of my
interpretations both appear to have problems.

Naively, I assumed that one should simply always use a zero IV, but
this appear to lead to loss of confidentiality in applications that
encrypts data in several chunks using the same key.  I believe rsh and
telnet would be examples of such applications.  They need to carry the
last IV on to the next encryption invocation, otherwise encryption
would use the same key stream for all encryptions.

I now think that what was intended was to re-iterate that the default
cipher state initialization vector should be zero, compare KCRYPTO.

   cipher state              initial vector (usually of length c)

   initial cipher state      all bits zero

   encryption function       conf = random string of length c
                             pad = shortest string to bring confounder
                                   and plaintext to a length that's a
                                   multiple of m
                             C1 = E(Ke, conf | plaintext | pad,
                                    oldstate.ivec)
                             H1 = HMAC(Ki, conf | plaintext | pad)
                             ciphertext =  C1 | H1[1..h]
                             newstate.ivec = last c of C1

Now read the last line carefully.  It set the next IV to the last (for
AES) 16 bytes of the cipher text; not the "new IV" generated by the E
function, compare the definition of E:

   encryption/decryption functions, E and D
      These are basic encryption and decryption functions for messages
      of sizes that are multiples of the message block size.  No
      integrity checking or confounder should be included here.  These
      functions take as input the IV or similar data, a protocol-format
      key, and a octet string, returning a new IV and octet string.

It is not clear what the next IV should be.  Is it the last c of C1 as
KCRYPTO says, or the new IV returned by AES-CTS?  The two are not
necessarily equal, depending on how you define "new IV" for CTS mode.
Note that neither the RC5 or AC references, given in the
specification, for CTS mode specify in the text what the "new IV"
should be, as far as I can tell.

There may even be security problems by using the last c of C1 as next
IV, although I haven't analyzed this in detail.  Consider encrypting a
string of length divisible by the block length, then CBC-CTS equals
CBC but with the last two block swapped.  If you use the last block as
the next IV then it appears this IV is re-used when encrypting both
the Cn-1 block and the C0 block in the next encryption operation.

If the "zero ivec" statement refer to something other than the above
two alternatives (which both appear to be problematic), please
elaborate the text.

Solution ideas:

* Remove the text "zero ivec" statement from the AES document, as a
  zero initial vector is implied by the KCRYPTO framework for the
  first encryption, and is simply wrong for subsequent encryptions.

* Change the simplified encryption function into:

                             (C1, newiv) = E(oldstate.ivec, Ke,
                                             conf | plaintext | pad)
                             H1 = HMAC(Ki, conf | plaintext | pad)
                             ciphertext =  C1 | H1[1..h]
                             newstate.ivec = newiv

* Clarify in the AES document to say the IV output of E should be the
  last c of the encrypted data.  This saves backwards compatibility to
  the existing drafts, but I'm not sure it reflect what existing
  non-Kerberos CTS implementations do wrt IV, and if my analysis above
  is correct, it also have security problems.

* Alternatively, make the AES document say that the IV output of E is
  the last output from the low-level AES primitive.

* (My, perhaps unrealistic, preference) Ditch the current AES spec and
  go for a well-specified and self-contained profile (i.e., not as a
  "simplified" crypto profile), proven secure, AEAD scheme.

Thanks for your time,
Simon

